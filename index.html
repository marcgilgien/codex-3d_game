<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Retro Fruit Dash</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #0b0f14;
      --neon-pink: #ff4fd8;
      --neon-cyan: #41f3ff;
      --neon-yellow: #f7ff00;
      --lawn: #1e9b3f;
      --lawn-dark: #13732e;
      --text: #e9f5ff;
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      height: 100%;
      background: radial-gradient(1200px 800px at 50% 20%, #1a2330 0%, #0b0f14 60%, #07090c 100%);
      color: var(--text);
      font-family: "Press Start 2P", monospace;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .wrap {
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: 16px;
    }

    .frame {
      padding: 16px;
      border: 4px solid var(--neon-cyan);
      box-shadow: 0 0 20px rgba(65, 243, 255, 0.4), inset 0 0 16px rgba(65, 243, 255, 0.3);
      background: linear-gradient(180deg, rgba(12,16,22,0.9), rgba(6,8,12,0.95));
    }

    .title {
      font-size: 14px;
      text-align: center;
      margin: 0 0 12px;
      color: var(--neon-pink);
      text-shadow: 0 0 8px rgba(255, 79, 216, 0.6);
    }

    canvas {
      display: block;
      background: repeating-linear-gradient(
        0deg,
        rgba(255,255,255,0.04) 0px,
        rgba(255,255,255,0.04) 1px,
        rgba(0,0,0,0) 2px,
        rgba(0,0,0,0) 4px
      );
      image-rendering: pixelated;
      border: 4px solid var(--neon-pink);
      box-shadow: 0 0 18px rgba(255, 79, 216, 0.5);
    }

    .hud {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 12px;
      align-items: center;
      margin-top: 12px;
      font-size: 10px;
    }

    .hud .center {
      text-align: center;
      color: var(--neon-yellow);
      text-shadow: 0 0 8px rgba(247, 255, 0, 0.6);
    }

    .pill {
      padding: 6px 8px;
      border: 2px solid var(--neon-cyan);
      background: rgba(65, 243, 255, 0.08);
    }

    .help {
      margin-top: 10px;
      font-size: 9px;
      color: #9bb3c7;
      text-align: center;
      line-height: 1.5;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
    }

    .message {
      background: rgba(6, 8, 12, 0.92);
      border: 3px solid var(--neon-yellow);
      padding: 16px 18px;
      text-align: center;
      font-size: 12px;
      line-height: 1.5;
      box-shadow: 0 0 18px rgba(247, 255, 0, 0.4);
    }

    .hidden { display: none; }

    .screen {
      position: relative;
      width: min(1280px, 92vw);
      aspect-ratio: 16 / 9;
    }

    #game {
      width: 100%;
      height: 100%;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }

    .touch-ui {
      display: none;
    }

    .touch-ui {
      margin-top: 14px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
      align-items: center;
      font-size: 10px;
      justify-items: end;
      width: 100%;
    }

    .dpad {
      display: grid;
      grid-template-columns: repeat(3, 72px);
      grid-template-rows: repeat(3, 72px);
      gap: 8px;
      justify-content: end;
      align-content: center;
      width: 100%;
      max-width: 420px;
    }

    .touch-btn {
      border: 2px solid var(--neon-cyan);
      background: rgba(65, 243, 255, 0.12);
      color: var(--text);
      font-family: "Press Start 2P", monospace;
      font-size: 9px;
      padding: 8px;
      text-align: center;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
    }

    .touch-btn svg {
      width: 18px;
      height: 18px;
      display: block;
      margin: 0 auto;
      fill: var(--text);
    }

    .touch-start svg {
      width: 22px;
      height: 22px;
    }

    .touch-ui {
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }

    .touch-btn:active {
      background: rgba(255, 79, 216, 0.2);
      border-color: var(--neon-pink);
    }

    .touch-start {
      justify-self: end;
      padding: 12px 14px;
      font-size: 9px;
    }

    @media (pointer: coarse) {
      .touch-ui {
        display: grid;
      }
      .dpad {
        background: rgba(15, 26, 40, 0.55);
        border: 2px solid rgba(65, 243, 255, 0.5);
        border-radius: 16px;
        padding: 10px;
      }
      .touch-btn {
        background: transparent;
        border-color: transparent;
      }
      .touch-btn svg {
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="frame">
      <h1 class="title">RETRO FRUIT DASH</h1>
      <div class="screen">
        <canvas id="game" width="1280" height="720"></canvas>
        <div class="overlay" id="overlay">
          <div class="message" id="message"></div>
        </div>
      </div>
      <div class="hud">
        <div class="pill" id="fruitCount">FRUITS: 0 / 50</div>
        <div class="center" id="timer">TIME: 30.0</div>
        <div class="pill" id="status">PRESS ENTER TO START</div>
      </div>
      <div class="help">
        Use arrow keys to run. Collect 50 fruits within 30 seconds.
      </div>
      <div class="touch-ui" aria-hidden="false">
        <div class="dpad" id="dpad">
          <div></div>
          <div class="touch-btn" data-dir="up" role="button" aria-label="Up">
            <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 4l8 10h-5v6H9v-6H4z"/></svg>
          </div>
          <div></div>
          <div class="touch-btn" data-dir="left" role="button" aria-label="Left">
            <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M4 12l10-8v5h6v6h-6v5z"/></svg>
          </div>
          <div class="touch-btn" data-dir="down" role="button" aria-label="Down">
            <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 20l-8-10h5V4h6v6h5z"/></svg>
          </div>
          <div class="touch-btn" data-dir="right" role="button" aria-label="Right">
            <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M20 12l-10 8v-5H4V9h6V4z"/></svg>
          </div>
          <div></div>
          <div></div>
          <div></div>
        </div>
        <button class="touch-btn touch-start" id="touchStart" type="button" aria-label="Start">
          <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M8 5l12 7-12 7z"/></svg>
        </button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const fruitCountEl = document.getElementById("fruitCount");
    const timerEl = document.getElementById("timer");
    const statusEl = document.getElementById("status");
    const overlayEl = document.getElementById("overlay");
    const messageEl = document.getElementById("message");
    const dpadEl = document.getElementById("dpad");
    const touchStartEl = document.getElementById("touchStart");

    const VIEW = { width: 1280, height: 720, horizon: 220 };
    const WORLD = { width: 520, depth: 1100 };
    const CAMERA_FOLLOW_Z = 120;
    const FOV = 720;

    const TARGET_FRUITS = 50;
    const GAME_TIME = 30;

    const player = {
      x: 0,
      z: 140,
      size: 45,
      speed: 360,
      vx: 0,
      vz: 0,
    };

    const fruits = [];
    const FRUIT_COUNT = 14;
    const monsters = [];
    const MONSTER_COUNT = 3;
    const camera = { x: 0, z: 0 };
    const renderState = {
      scale: 1,
      offsetX: 0,
      offsetY: 0,
      dpr: 1,
    };

    let collected = 0;
    let timeLeft = GAME_TIME;
    let running = false;
    let lastTime = 0;

    const keys = new Set();
    let audioCtx = null;
    let musicInterval = null;
    let musicStep = 0;
    let musicHectic = false;

    function resetGame() {
      player.x = 0;
      player.z = 140;
      collected = 0;
      timeLeft = GAME_TIME;
      musicHectic = false;
      fruits.length = 0;
      monsters.length = 0;
      for (let i = 0; i < FRUIT_COUNT; i++) {
        fruits.push(spawnFruit());
      }
      for (let i = 0; i < MONSTER_COUNT; i++) {
        monsters.push(spawnMonster());
      }
      updateHUD();
      statusEl.textContent = "RUN!";
      overlayEl.classList.add("hidden");
      messageEl.textContent = "";
      startMusic();
    }

    function spawnFruit() {
      const spawnRadiusX = WORLD.width * 0.6;
      const spawnDepth = WORLD.depth * 0.6;
      return {
        x: player.x + (Math.random() - 0.5) * spawnRadiusX * 2,
        z: player.z + 60 + Math.random() * spawnDepth,
        r: 16 + Math.random() * 7,
        color: ["#2d9cff", "#4fc3ff", "#1e6bff", "#7aa6ff"][Math.floor(Math.random() * 4)],
      };
    }

    function spawnMonster() {
      const spawnRadiusX = WORLD.width * 0.7;
      const spawnDepth = WORLD.depth * 0.7;
      return {
        x: player.x + (Math.random() - 0.5) * spawnRadiusX * 2,
        z: player.z + 80 + Math.random() * spawnDepth,
        r: 26 + Math.random() * 11,
        color: "#ff3b3b",
        eye: "#f7ff00",
      };
    }

    function updateHUD() {
      fruitCountEl.textContent = `FRUITS: ${collected} / ${TARGET_FRUITS}`;
      timerEl.textContent = `TIME: ${timeLeft.toFixed(1)}`;
    }

    function project(x, z) {
      const relX = x - camera.x;
      const relZ = z - camera.z;
      const safeZ = Math.max(10, relZ);
      const scale = FOV / (FOV + safeZ);
      return {
        x: VIEW.width / 2 + relX * scale,
        y: VIEW.horizon + safeZ * scale,
        scale,
        z: relZ,
      };
    }

    function drawBackground() {
      const horizon = VIEW.horizon;
      ctx.fillStyle = "#1e9b3f";
      ctx.fillRect(0, 0, VIEW.width, VIEW.height);

      // perspective stripes
      ctx.strokeStyle = "rgba(0,0,0,0.18)";
      ctx.lineWidth = 2;
      for (let i = 0; i < 18; i++) {
        const z = camera.z + (i / 18) * WORLD.depth;
        const p1 = project(camera.x - WORLD.width / 2, z);
        const p2 = project(camera.x + WORLD.width / 2, z);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }

      // lane lines
      ctx.strokeStyle = "rgba(255,255,255,0.15)";
      for (let i = -2; i <= 2; i++) {
        const x = camera.x + (i / 2) * (WORLD.width / 2);
        ctx.beginPath();
        const near = project(x, camera.z);
        const far = project(x, camera.z + WORLD.depth);
        ctx.moveTo(near.x, near.y);
        ctx.lineTo(far.x, far.y);
        ctx.stroke();
      }
    }

    function drawPlayer() {
      const { x, z, size } = player;
      const p = project(x, z);
      const s = size * p.scale;

      // shadow
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(p.x - s / 2 + 2, p.y + s / 2 - 2, s, Math.max(2, s * 0.25));

      // body
      ctx.fillStyle = "#59b8ff";
      ctx.fillRect(p.x - s / 2, p.y - s / 2, s, s);

      // face
      ctx.fillStyle = "#ffd6a6";
      ctx.fillRect(p.x - s * 0.25, p.y - s * 0.35, s * 0.5, s * 0.35);

      // eyes
      ctx.fillStyle = "#2b1a14";
      ctx.fillRect(p.x - s * 0.18, p.y - s * 0.28, s * 0.08, s * 0.08);
      ctx.fillRect(p.x + s * 0.1, p.y - s * 0.28, s * 0.08, s * 0.08);

      // blonde hair
      ctx.fillStyle = "#ffe066";
      ctx.fillRect(p.x - s * 0.35, p.y - s * 0.65, s * 0.7, s * 0.25);

      // ponytails
      ctx.fillRect(p.x - s * 0.6, p.y - s * 0.5, s * 0.25, s * 0.35);
      ctx.fillRect(p.x + s * 0.35, p.y - s * 0.5, s * 0.25, s * 0.35);

      // boots
      ctx.fillStyle = "#f3ff6a";
      ctx.fillRect(p.x - s * 0.35, p.y + s * 0.25, s * 0.25, s * 0.2);
      ctx.fillRect(p.x + s * 0.1, p.y + s * 0.25, s * 0.25, s * 0.2);
    }

    function drawFruits() {
      const sorted = [...fruits].sort((a, b) => (a.z - camera.z) - (b.z - camera.z));
      for (const fruit of sorted) {
        const p = project(fruit.x, fruit.z);
        if (p.z < 10) continue;
        const r = fruit.r * p.scale;
        ctx.fillStyle = fruit.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y - r * 0.6, r, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#3a2f0b";
        ctx.fillRect(p.x - r * 0.1, p.y - r * 1.3, r * 0.2, r * 0.5);
      }
    }

    function drawMonsters() {
      const sorted = [...monsters].sort((a, b) => (a.z - camera.z) - (b.z - camera.z));
      for (const monster of sorted) {
        const p = project(monster.x, monster.z);
        if (p.z < 10) continue;
        const r = monster.r * p.scale;
        const w = r * 1.6;
        const h = r * 1.1;
        const blink = Math.sin(performance.now() * 0.012 + monster.x * 0.02 + monster.z * 0.01) > 0.2;

        ctx.fillStyle = monster.color;
        ctx.fillRect(p.x - w / 2, p.y - h * 0.6, w, h);

        ctx.fillStyle = monster.eye;
        if (blink) {
          ctx.fillRect(p.x - w * 0.3, p.y - h * 0.35, w * 0.18, h * 0.18);
          ctx.fillRect(p.x + w * 0.12, p.y - h * 0.35, w * 0.18, h * 0.18);
        } else {
          ctx.fillRect(p.x - w * 0.32, p.y - h * 0.28, w * 0.22, h * 0.06);
          ctx.fillRect(p.x + w * 0.1, p.y - h * 0.28, w * 0.22, h * 0.06);
        }

        ctx.fillStyle = "#0b0f14";
        ctx.fillRect(p.x - w * 0.25, p.y + h * 0.05, w * 0.5, h * 0.12);
      }
    }

    function updatePlayer(dt) {
      player.vx = 0;
      player.vz = 0;

      if (keys.has("ArrowLeft")) player.vx -= player.speed;
      if (keys.has("ArrowRight")) player.vx += player.speed;
      if (keys.has("ArrowUp")) player.vz -= player.speed;
      if (keys.has("ArrowDown")) player.vz += player.speed;

      if (player.vx !== 0 && player.vz !== 0) {
        player.vx *= 0.7;
        player.vz *= 0.7;
      }

      player.x += player.vx * dt;
      player.z += player.vz * dt;

      camera.x = player.x;
      camera.z = player.z - CAMERA_FOLLOW_Z;
    }

    function checkCollisions() {
      for (let i = fruits.length - 1; i >= 0; i--) {
        const fruit = fruits[i];
        const dx = fruit.x - player.x;
        const dz = fruit.z - player.z;
        const dist = Math.hypot(dx, dz);
        if (dist < fruit.r + player.size / 2) {
          fruits.splice(i, 1);
          collected += 1;
          fruits.push(spawnFruit());
          playEatSound();
        }
      }

      for (let i = 0; i < monsters.length; i++) {
        const monster = monsters[i];
        const dx = monster.x - player.x;
        const dz = monster.z - player.z;
        const dist = Math.hypot(dx, dz);
        if (dist < monster.r + player.size / 2) {
          endGame(false);
          return;
        }
      }
    }

    function update(dt) {
      if (!running) return;

      timeLeft -= dt;
      if (timeLeft <= 0) {
        timeLeft = 0;
        endGame(false);
        return;
      }

      if (!musicHectic && timeLeft <= 10) {
        musicHectic = true;
        startMusic();
      }

      updatePlayer(dt);
      checkCollisions();

      for (let i = fruits.length - 1; i >= 0; i--) {
        const fruit = fruits[i];
        if (fruit.z < camera.z - 40 || fruit.z > camera.z + WORLD.depth + 120 ||
            Math.abs(fruit.x - camera.x) > WORLD.width) {
          fruits.splice(i, 1);
          fruits.push(spawnFruit());
        }
      }

      for (let i = monsters.length - 1; i >= 0; i--) {
        const monster = monsters[i];
        if (monster.z < camera.z - 60 || monster.z > camera.z + WORLD.depth + 140 ||
            Math.abs(monster.x - camera.x) > WORLD.width) {
          monsters.splice(i, 1);
          monsters.push(spawnMonster());
        }
      }

      if (collected >= TARGET_FRUITS) {
        endGame(true);
      }

      updateHUD();
    }

    function draw() {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(renderState.scale, 0, 0, renderState.scale, renderState.offsetX, renderState.offsetY);
      drawBackground();
      drawFruits();
      drawMonsters();
      drawPlayer();
    }

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = Math.min(0.033, (timestamp - lastTime) / 1000);
      lastTime = timestamp;

      update(dt);
      draw();
      resizeCanvas();
      requestAnimationFrame(loop);
    }

    function endGame(win) {
      running = false;
      statusEl.textContent = "PRESS ENTER";
      overlayEl.classList.remove("hidden");
      messageEl.textContent = win
        ? "YOU WIN! 50 FRUITS!"
        : "TIME UP! TRY AGAIN";
      stopMusic();
      if (win) {
        playWinSound();
      } else {
        playLoseSound();
      }
    }

    function ensureAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === "suspended") {
        audioCtx.resume();
      }
    }

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      const width = Math.floor(rect.width * dpr);
      const height = Math.floor(rect.height * dpr);
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
      }
      const scale = Math.min(rect.width / VIEW.width, rect.height / VIEW.height);
      renderState.dpr = dpr;
      renderState.scale = scale * dpr;
      renderState.offsetX = (canvas.width - VIEW.width * renderState.scale) / 2;
      renderState.offsetY = (canvas.height - VIEW.height * renderState.scale) / 2;
    }

    function playEatSound() {
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "square";
      osc.frequency.setValueAtTime(520, now);
      osc.frequency.exponentialRampToValueAtTime(880, now + 0.08);
      gain.gain.setValueAtTime(0.08, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.12);
    }

    function playWinSound() {
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(440, now);
      osc.frequency.exponentialRampToValueAtTime(880, now + 0.2);
      osc.frequency.exponentialRampToValueAtTime(1320, now + 0.4);
      gain.gain.setValueAtTime(0.08, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.5);
    }

    function playLoseSound() {
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "sawtooth";
      osc.frequency.setValueAtTime(520, now);
      osc.frequency.exponentialRampToValueAtTime(220, now + 0.35);
      gain.gain.setValueAtTime(0.07, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.4);
    }

    function playNote(freq, duration, type, gainValue) {
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, now);
      gain.gain.setValueAtTime(gainValue, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + duration);
    }

    function startMusic() {
      stopMusic();
      if (!audioCtx) return;
      musicStep = 0;
      const mellowTempo = 220;
      const hecticTempo = 120;
      const interval = musicHectic ? hecticTempo : mellowTempo;
      const melodyMellow = [392, 440, 392, 349, 330, 349, 392, 440];
      const melodyHectic = [523, 587, 659, 587, 523, 494, 523, 494];
      const bassMellow = [131, 147, 165, 147];
      const bassHectic = [165, 196, 220, 196];

      musicInterval = setInterval(() => {
        const melody = musicHectic ? melodyHectic : melodyMellow;
        const bass = musicHectic ? bassHectic : bassMellow;
        const step = musicStep % melody.length;
        const bassStep = musicStep % bass.length;

        playNote(melody[step], musicHectic ? 0.18 : 0.28, "triangle", 0.04);
        if (musicStep % 2 === 0) {
          playNote(bass[bassStep], musicHectic ? 0.22 : 0.3, "square", 0.03);
        }
        if (musicHectic && musicStep % 2 === 1) {
          playNote(880, 0.06, "square", 0.015);
        }

        musicStep += 1;
      }, interval);
    }

    function stopMusic() {
      if (musicInterval) {
        clearInterval(musicInterval);
        musicInterval = null;
      }
    }

    window.addEventListener("keydown", (e) => {
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(e.key)) {
        e.preventDefault();
      }

      if (e.key === "Enter") {
        startGame();
        return;
      }

      if (e.key.startsWith("Arrow")) {
        ensureAudio();
      }
      keys.add(e.key);
    });

    window.addEventListener("keyup", (e) => {
      keys.delete(e.key);
    });

    function startGame() {
      ensureAudio();
      running = true;
      resetGame();
      lastTime = performance.now();
    }

    canvas.addEventListener("pointerdown", () => {
      if (!running) startGame();
    });

    overlayEl.addEventListener("pointerdown", () => {
      if (!running) startGame();
    });

    touchStartEl.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      if (!running) startGame();
    });

    function bindTouchButton(el, key) {
      const setKey = (down) => {
        if (down) {
          keys.add(key);
          ensureAudio();
        } else {
          keys.delete(key);
        }
      };
      el.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        setKey(true);
      });
      el.addEventListener("pointerup", (e) => {
        e.preventDefault();
        setKey(false);
      });
      el.addEventListener("pointercancel", () => setKey(false));
      el.addEventListener("pointerleave", () => setKey(false));
    }

    if (dpadEl) {
      dpadEl.querySelectorAll("[data-dir]").forEach((btn) => {
        const dir = btn.getAttribute("data-dir");
        const key =
          dir === "up" ? "ArrowUp" :
          dir === "down" ? "ArrowDown" :
          dir === "left" ? "ArrowLeft" :
          "ArrowRight";
        bindTouchButton(btn, key);
      });

      let dragging = false;
      let activePointerId = null;

      const setDirKeys = (dx, dy) => {
        const threshold = 12;
        if (dx < -threshold) keys.add("ArrowLeft"); else keys.delete("ArrowLeft");
        if (dx > threshold) keys.add("ArrowRight"); else keys.delete("ArrowRight");
        if (dy < -threshold) keys.add("ArrowUp"); else keys.delete("ArrowUp");
        if (dy > threshold) keys.add("ArrowDown"); else keys.delete("ArrowDown");
        ensureAudio();
      };

      const clearDirKeys = () => {
        ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].forEach((k) => keys.delete(k));
      };

      dpadEl.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        dragging = true;
        activePointerId = e.pointerId;
        dpadEl.setPointerCapture(e.pointerId);
        const rect = dpadEl.getBoundingClientRect();
        const dx = e.clientX - (rect.left + rect.width / 2);
        const dy = e.clientY - (rect.top + rect.height / 2);
        setDirKeys(dx, dy);
      });

      dpadEl.addEventListener("pointermove", (e) => {
        if (!dragging || e.pointerId !== activePointerId) return;
        const rect = dpadEl.getBoundingClientRect();
        const dx = e.clientX - (rect.left + rect.width / 2);
        const dy = e.clientY - (rect.top + rect.height / 2);
        setDirKeys(dx, dy);
      });

      const endDrag = (e) => {
        if (e.pointerId !== activePointerId) return;
        dragging = false;
        activePointerId = null;
        clearDirKeys();
      };

      dpadEl.addEventListener("pointerup", endDrag);
      dpadEl.addEventListener("pointercancel", endDrag);
      dpadEl.addEventListener("pointerleave", (e) => {
        if (!dragging) return;
        endDrag(e);
      });
    }

    document.querySelectorAll(".touch-btn").forEach((btn) => {
      btn.addEventListener("contextmenu", (e) => e.preventDefault());
      btn.addEventListener("touchstart", (e) => e.preventDefault(), { passive: false });
    });

    let lastTouchEnd = 0;
    document.addEventListener("touchend", (e) => {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) {
        e.preventDefault();
      }
      lastTouchEnd = now;
    }, { passive: false });

    overlayEl.classList.remove("hidden");
    messageEl.textContent = "PRESS ENTER TO START";

    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);
    window.addEventListener("orientationchange", resizeCanvas);
    requestAnimationFrame(loop);
  </script>
</body>
</html>
