<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Retro Fruit Dash</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #0b0f14;
      --neon-pink: #ff4fd8;
      --neon-cyan: #41f3ff;
      --neon-yellow: #f7ff00;
      --lawn: #1e9b3f;
      --lawn-dark: #13732e;
      --text: #e9f5ff;
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      height: 100%;
      background: radial-gradient(1200px 800px at 50% 20%, #1a2330 0%, #0b0f14 60%, #07090c 100%);
      color: var(--text);
      font-family: "Press Start 2P", monospace;
    }

    .wrap {
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: 16px;
    }

    .frame {
      padding: 16px;
      border: 4px solid var(--neon-cyan);
      box-shadow: 0 0 20px rgba(65, 243, 255, 0.4), inset 0 0 16px rgba(65, 243, 255, 0.3);
      background: linear-gradient(180deg, rgba(12,16,22,0.9), rgba(6,8,12,0.95));
    }

    .title {
      font-size: 14px;
      text-align: center;
      margin: 0 0 12px;
      color: var(--neon-pink);
      text-shadow: 0 0 8px rgba(255, 79, 216, 0.6);
    }

    canvas {
      display: block;
      background: repeating-linear-gradient(
        0deg,
        rgba(255,255,255,0.04) 0px,
        rgba(255,255,255,0.04) 1px,
        rgba(0,0,0,0) 2px,
        rgba(0,0,0,0) 4px
      );
      image-rendering: pixelated;
      border: 4px solid var(--neon-pink);
      box-shadow: 0 0 18px rgba(255, 79, 216, 0.5);
    }

    .hud {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 12px;
      align-items: center;
      margin-top: 12px;
      font-size: 10px;
    }

    .hud .center {
      text-align: center;
      color: var(--neon-yellow);
      text-shadow: 0 0 8px rgba(247, 255, 0, 0.6);
    }

    .pill {
      padding: 6px 8px;
      border: 2px solid var(--neon-cyan);
      background: rgba(65, 243, 255, 0.08);
    }

    .help {
      margin-top: 10px;
      font-size: 9px;
      color: #9bb3c7;
      text-align: center;
      line-height: 1.5;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
    }

    .message {
      background: rgba(6, 8, 12, 0.92);
      border: 3px solid var(--neon-yellow);
      padding: 16px 18px;
      text-align: center;
      font-size: 12px;
      line-height: 1.5;
      box-shadow: 0 0 18px rgba(247, 255, 0, 0.4);
    }

    .hidden { display: none; }

    .screen {
      position: relative;
      width: 1280px;
      height: 720px;
    }

    @media (max-width: 720px) {
      .screen { width: 90vw; height: 50.625vw; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="frame">
      <h1 class="title">RETRO FRUIT DASH</h1>
      <div class="screen">
        <canvas id="game" width="1280" height="720"></canvas>
        <div class="overlay" id="overlay">
          <div class="message" id="message"></div>
        </div>
      </div>
      <div class="hud">
        <div class="pill" id="fruitCount">FRUITS: 0 / 60</div>
        <div class="center" id="timer">TIME: 30.0</div>
        <div class="pill" id="status">PRESS ENTER TO START</div>
      </div>
      <div class="help">
        Use arrow keys to run. Collect 60 fruits within 30 seconds.
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const fruitCountEl = document.getElementById("fruitCount");
    const timerEl = document.getElementById("timer");
    const statusEl = document.getElementById("status");
    const overlayEl = document.getElementById("overlay");
    const messageEl = document.getElementById("message");

    const VIEW = { width: 1280, height: 720, horizon: 220 };
    const WORLD = { width: 520, depth: 1100 };
    const CAMERA_FOLLOW_Z = 120;
    const FOV = 720;

    const TARGET_FRUITS = 60;
    const GAME_TIME = 30;

    const player = {
      x: 0,
      z: 140,
      size: 45,
      speed: 360,
      vx: 0,
      vz: 0,
    };

    const fruits = [];
    const FRUIT_COUNT = 14;
    const camera = { x: 0, z: 0 };

    let collected = 0;
    let timeLeft = GAME_TIME;
    let running = false;
    let lastTime = 0;

    const keys = new Set();
    let audioCtx = null;
    let musicInterval = null;
    let musicStep = 0;
    let musicHectic = false;

    function resetGame() {
      player.x = 0;
      player.z = 140;
      collected = 0;
      timeLeft = GAME_TIME;
      musicHectic = false;
      fruits.length = 0;
      for (let i = 0; i < FRUIT_COUNT; i++) {
        fruits.push(spawnFruit());
      }
      updateHUD();
      statusEl.textContent = "RUN!";
      overlayEl.classList.add("hidden");
      messageEl.textContent = "";
      startMusic();
    }

    function spawnFruit() {
      const spawnRadiusX = WORLD.width * 0.6;
      const spawnDepth = WORLD.depth * 0.6;
      return {
        x: player.x + (Math.random() - 0.5) * spawnRadiusX * 2,
        z: player.z + 60 + Math.random() * spawnDepth,
        r: 16 + Math.random() * 7,
        color: ["#ff3b3b", "#ff9f1c", "#b7ff5a", "#ff4fd8"][Math.floor(Math.random() * 4)],
      };
    }

    function updateHUD() {
      fruitCountEl.textContent = `FRUITS: ${collected} / ${TARGET_FRUITS}`;
      timerEl.textContent = `TIME: ${timeLeft.toFixed(1)}`;
    }

    function project(x, z) {
      const relX = x - camera.x;
      const relZ = z - camera.z;
      const safeZ = Math.max(10, relZ);
      const scale = FOV / (FOV + safeZ);
      return {
        x: VIEW.width / 2 + relX * scale,
        y: VIEW.horizon + safeZ * scale,
        scale,
        z: relZ,
      };
    }

    function drawBackground() {
      ctx.fillStyle = "#0c1220";
      ctx.fillRect(0, 0, VIEW.width, VIEW.height);

      const horizon = VIEW.horizon;
      ctx.fillStyle = "#152033";
      ctx.fillRect(0, 0, VIEW.width, horizon + 6);

      // ground
      ctx.fillStyle = "#1e9b3f";
      ctx.beginPath();
      ctx.moveTo(0, horizon + 6);
      ctx.lineTo(VIEW.width, horizon + 6);
      ctx.lineTo(VIEW.width, VIEW.height);
      ctx.lineTo(0, VIEW.height);
      ctx.closePath();
      ctx.fill();

      // perspective stripes
      ctx.strokeStyle = "rgba(0,0,0,0.18)";
      ctx.lineWidth = 2;
      for (let i = 0; i < 18; i++) {
        const z = camera.z + (i / 18) * WORLD.depth;
        const p1 = project(camera.x - WORLD.width / 2, z);
        const p2 = project(camera.x + WORLD.width / 2, z);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }

      // lane lines
      ctx.strokeStyle = "rgba(255,255,255,0.15)";
      for (let i = -2; i <= 2; i++) {
        const x = camera.x + (i / 2) * (WORLD.width / 2);
        ctx.beginPath();
        const near = project(x, camera.z);
        const far = project(x, camera.z + WORLD.depth);
        ctx.moveTo(near.x, near.y);
        ctx.lineTo(far.x, far.y);
        ctx.stroke();
      }
    }

    function drawPlayer() {
      const { x, z, size } = player;
      const p = project(x, z);
      const s = size * p.scale;

      // shadow
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(p.x - s / 2 + 2, p.y + s / 2 - 2, s, Math.max(2, s * 0.25));

      // body
      ctx.fillStyle = "#59b8ff";
      ctx.fillRect(p.x - s / 2, p.y - s / 2, s, s);

      // face
      ctx.fillStyle = "#ffd6a6";
      ctx.fillRect(p.x - s * 0.25, p.y - s * 0.35, s * 0.5, s * 0.35);

      // eyes
      ctx.fillStyle = "#2b1a14";
      ctx.fillRect(p.x - s * 0.18, p.y - s * 0.28, s * 0.08, s * 0.08);
      ctx.fillRect(p.x + s * 0.1, p.y - s * 0.28, s * 0.08, s * 0.08);

      // blonde hair
      ctx.fillStyle = "#ffe066";
      ctx.fillRect(p.x - s * 0.35, p.y - s * 0.65, s * 0.7, s * 0.25);

      // ponytails
      ctx.fillRect(p.x - s * 0.6, p.y - s * 0.5, s * 0.25, s * 0.35);
      ctx.fillRect(p.x + s * 0.35, p.y - s * 0.5, s * 0.25, s * 0.35);

      // boots
      ctx.fillStyle = "#f3ff6a";
      ctx.fillRect(p.x - s * 0.35, p.y + s * 0.25, s * 0.25, s * 0.2);
      ctx.fillRect(p.x + s * 0.1, p.y + s * 0.25, s * 0.25, s * 0.2);
    }

    function drawFruits() {
      const sorted = [...fruits].sort((a, b) => (a.z - camera.z) - (b.z - camera.z));
      for (const fruit of sorted) {
        const p = project(fruit.x, fruit.z);
        if (p.z < 10) continue;
        const r = fruit.r * p.scale;
        ctx.fillStyle = fruit.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y - r * 0.6, r, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#3a2f0b";
        ctx.fillRect(p.x - r * 0.1, p.y - r * 1.3, r * 0.2, r * 0.5);
      }
    }

    function updatePlayer(dt) {
      player.vx = 0;
      player.vz = 0;

      if (keys.has("ArrowLeft")) player.vx -= player.speed;
      if (keys.has("ArrowRight")) player.vx += player.speed;
      if (keys.has("ArrowUp")) player.vz -= player.speed;
      if (keys.has("ArrowDown")) player.vz += player.speed;

      if (player.vx !== 0 && player.vz !== 0) {
        player.vx *= 0.7;
        player.vz *= 0.7;
      }

      player.x += player.vx * dt;
      player.z += player.vz * dt;

      camera.x = player.x;
      camera.z = player.z - CAMERA_FOLLOW_Z;
    }

    function checkCollisions() {
      for (let i = fruits.length - 1; i >= 0; i--) {
        const fruit = fruits[i];
        const dx = fruit.x - player.x;
        const dz = fruit.z - player.z;
        const dist = Math.hypot(dx, dz);
        if (dist < fruit.r + player.size / 2) {
          fruits.splice(i, 1);
          collected += 1;
          fruits.push(spawnFruit());
          playEatSound();
        }
      }
    }

    function update(dt) {
      if (!running) return;

      timeLeft -= dt;
      if (timeLeft <= 0) {
        timeLeft = 0;
        endGame(false);
        return;
      }

      if (!musicHectic && timeLeft <= 10) {
        musicHectic = true;
        startMusic();
      }

      updatePlayer(dt);
      checkCollisions();

      for (let i = fruits.length - 1; i >= 0; i--) {
        const fruit = fruits[i];
        if (fruit.z < camera.z - 40 || fruit.z > camera.z + WORLD.depth + 120 ||
            Math.abs(fruit.x - camera.x) > WORLD.width) {
          fruits.splice(i, 1);
          fruits.push(spawnFruit());
        }
      }

      if (collected >= TARGET_FRUITS) {
        endGame(true);
      }

      updateHUD();
    }

    function draw() {
      drawBackground();
      drawFruits();
      drawPlayer();
    }

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = Math.min(0.033, (timestamp - lastTime) / 1000);
      lastTime = timestamp;

      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    function endGame(win) {
      running = false;
      statusEl.textContent = "PRESS ENTER";
      overlayEl.classList.remove("hidden");
      messageEl.textContent = win
        ? "YOU WIN! 60 FRUITS!"
        : "TIME UP! TRY AGAIN";
      stopMusic();
      if (win) {
        playWinSound();
      } else {
        playLoseSound();
      }
    }

    function ensureAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === "suspended") {
        audioCtx.resume();
      }
    }

    function playEatSound() {
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "square";
      osc.frequency.setValueAtTime(520, now);
      osc.frequency.exponentialRampToValueAtTime(880, now + 0.08);
      gain.gain.setValueAtTime(0.08, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.12);
    }

    function playWinSound() {
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(440, now);
      osc.frequency.exponentialRampToValueAtTime(880, now + 0.2);
      osc.frequency.exponentialRampToValueAtTime(1320, now + 0.4);
      gain.gain.setValueAtTime(0.08, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.5);
    }

    function playLoseSound() {
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "sawtooth";
      osc.frequency.setValueAtTime(520, now);
      osc.frequency.exponentialRampToValueAtTime(220, now + 0.35);
      gain.gain.setValueAtTime(0.07, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.4);
    }

    function playNote(freq, duration, type, gainValue) {
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, now);
      gain.gain.setValueAtTime(gainValue, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + duration);
    }

    function startMusic() {
      stopMusic();
      if (!audioCtx) return;
      musicStep = 0;
      const mellowTempo = 220;
      const hecticTempo = 120;
      const interval = musicHectic ? hecticTempo : mellowTempo;
      const melodyMellow = [392, 440, 392, 349, 330, 349, 392, 440];
      const melodyHectic = [523, 587, 659, 587, 523, 494, 523, 494];
      const bassMellow = [131, 147, 165, 147];
      const bassHectic = [165, 196, 220, 196];

      musicInterval = setInterval(() => {
        const melody = musicHectic ? melodyHectic : melodyMellow;
        const bass = musicHectic ? bassHectic : bassMellow;
        const step = musicStep % melody.length;
        const bassStep = musicStep % bass.length;

        playNote(melody[step], musicHectic ? 0.18 : 0.28, "triangle", 0.04);
        if (musicStep % 2 === 0) {
          playNote(bass[bassStep], musicHectic ? 0.22 : 0.3, "square", 0.03);
        }
        if (musicHectic && musicStep % 2 === 1) {
          playNote(880, 0.06, "square", 0.015);
        }

        musicStep += 1;
      }, interval);
    }

    function stopMusic() {
      if (musicInterval) {
        clearInterval(musicInterval);
        musicInterval = null;
      }
    }

    window.addEventListener("keydown", (e) => {
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(e.key)) {
        e.preventDefault();
      }

      if (e.key === "Enter") {
        ensureAudio();
        running = true;
        resetGame();
        lastTime = performance.now();
        return;
      }

      if (e.key.startsWith("Arrow")) {
        ensureAudio();
      }
      keys.add(e.key);
    });

    window.addEventListener("keyup", (e) => {
      keys.delete(e.key);
    });

    overlayEl.classList.remove("hidden");
    messageEl.textContent = "PRESS ENTER TO START";

    requestAnimationFrame(loop);
  </script>
</body>
</html>
